# goit-algo-hw-09

### Висновки з порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування для видачі решти

### Результати:

#### Сума: 1000
- Жадібний алгоритм: {50: 20}, час виконання: 2.15e-06 сек
- Алгоритм динамічного програмування: {50: 20}, час виконання: 0.00082 сек

#### Сума: 5000
- Жадібний алгоритм: {50: 100}, час виконання: 2.15e-06 сек
- Алгоритм динамічного програмування: {50: 100}, час виконання: 0.0036 сек

#### Сума: 10000
- Жадібний алгоритм: {50: 200}, час виконання: 9.54e-07 сек
- Алгоритм динамічного програмування: {50: 200}, час виконання: 0.0083 сек

#### Сума: 50000
- Жадібний алгоритм: {50: 1000}, час виконання: 1.91e-06 сек
- Алгоритм динамічного програмування: {50: 1000}, час виконання: 0.048 сек

#### Сума: 100000
- Жадібний алгоритм: {50: 2000}, час виконання: 3.10e-06 сек
- Алгоритм динамічного програмування: {50: 2000}, час виконання: 0.089 сек

### Висновки:
- Час виконання: Жадібний алгоритм виявляє значно кращу продуктивність у порівнянні з алгоритмом динамічного програмування для невеликих сум (1000, 5000, 10000). Однак, зі зростанням суми, алгоритм динамічного програмування виявляється менш ефективним за жадібний.
- Складність алгоритмів: Жадібний алгоритм має складність O(n), де n - кількість різних монет. Алгоритм динамічного програмування має складність O(amount * n), де amount - сума, а n - кількість різних монет. Отже, для великих сум, алгоритм динамічного програмування виявляється менш ефективним через свою вищу складність.
- Ефективність застосування: Жадібний алгоритм може бути ефективним у випадках, коли набори монет мають певні властивості (наприклад, величина найбільшого номіналу монети). Алгоритм динамічного програмування є більш універсальним і ефективним для будь-яких наборів монет та сум, проте за великих сум він може бути менш продуктивним через свою складність.


Загалом, обидва алгоритми мають свої переваги та недоліки в залежності від умов задачі та вхідних даних.
